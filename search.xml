<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[numpy教程1]]></title>
    <url>%2F2018%2F10%2F30%2Fnumpy%E6%95%99%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[3-2 魔法命令12 %run %timeit %time* 1%lsmagic Available line magics: %alias %alias_magic %autocall %automagic %autosave %bookmark %cd %clear %cls %colors %config %connect_info %copy %ddir %debug %dhist %dirs %doctest_mode %echo %ed %edit %env %gui %hist %history %killbgscripts %ldir %less %load %load_ext %loadpy %logoff %logon %logstart %logstate %logstop %ls %lsmagic %macro %magic %matplotlib %mkdir %more %notebook %page %pastebin %pdb %pdef %pdoc %pfile %pinfo %pinfo2 %popd %pprint %precision %profile %prun %psearch %psource %pushd %pwd %pycat %pylab %qtconsole %quickref %recall %rehashx %reload_ext %ren %rep %rerun %reset %reset_selective %rmdir %run %save %sc %set_env %store %sx %system %tb %time %timeit %unalias %unload_ext %who %who_ls %whos %xdel %xmode Available cell magics: %%! %%HTML %%SVG %%bash %%capture %%cmd %%debug %%file %%html %%javascript %%js %%latex %%perl %%prun %%pypy %%python %%python2 %%python3 %%ruby %%script %%sh %%svg %%sx %%system %%time %%timeit %%writefile Automagic is ON, % prefix IS NOT needed for line magics. 1% run? 1% run 1% run D:/xu/桌面/test.py test the run magic command 3-3 3-4 numpy dtype zeros ones full arange random dtype123import numpy as npnparr = np.array([i for i in range(10)])nparr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1nparr.dtype dtype(&apos;int32&apos;) 12nparr2=np.array([1,2,3.0])nparr2 array([ 1., 2., 3.]) 1nparr2.dtype dtype(&apos;float64&apos;) zeros ones full1np.zeros(10) array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) 1np.zeros(10,dtype=int) array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 1np.zeros((3,5)) array([[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]) 1np.ones(10) array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]) 1np.ones((3,5)) array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]]) 1np.full(shape = (3,5),fill_value = 666) array([[666, 666, 666, 666, 666], [666, 666, 666, 666, 666], [666, 666, 666, 666, 666]]) 1?np.full numpy 中的 arange1np.arange(0,20) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) 1np.arange(0,20,2) array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]) 1np.linspace(0,20,10) array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 1np.linspace(0,20,9) array([ 0. , 2.5, 5. , 7.5, 10. , 12.5, 15. , 17.5, 20. ]) numpy中的random1np.random.randint(0,10) #包括0，但是不包括10 8 1np.random.randint(0,10,size=10) array([5, 1, 3, 2, 3, 6, 1, 9, 0, 0]) 1np.random.randint(4,8,size=(3,5)) array([[5, 4, 7, 6, 7], [4, 7, 4, 4, 7], [6, 4, 4, 7, 4]]) 12np.random.seed(666)np.random.random() 0.7004371218578347 1np.random.random((3,5)) array([[0.84418664, 0.67651434, 0.72785806, 0.95145796, 0.0127032 ], [0.4135877 , 0.04881279, 0.09992856, 0.50806631, 0.20024754], [0.74415417, 0.192892 , 0.70084475, 0.29322811, 0.77447945]]) 1np.random.normal() -0.2987326181735221 1np.random.normal(10,100) #均值为10，方差为100 -36.05873749347232 1np.random.normal(0,1,(3,5)) array([[-1.08879299, -0.57577075, -1.68290077, 0.22918525, -1.75662522], [ 0.84463262, 0.27721986, 0.85290153, 0.1945996 , 1.31063772], [ 1.5438436 , -0.52904802, -0.6564723 , -0.2015057 , -0.70061583]]) 3-5 numpy array 的基本操作1x = np.arange(15).reshape(3,5) 1x array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 1x.ndim #维度 2 1x.shape #形状 (3, 5) 1x.size #元素个数 15 1x[0][0] #不建议这么访问 0 1x[(0,0)] #这样访问才对 0 1x[0,0] #或者去掉括号，简写 0 1x[0:1] #访问第一行元素 相当于 x[0:1,:] array([[0, 1, 2, 3, 4]]) 1x[::2] #相当于x[::2,:] array([[ 0, 1, 2, 3, 4], [10, 11, 12, 13, 14]]) 1x[::-1] #相当于x[::-1,:] array([[10, 11, 12, 13, 14], [ 5, 6, 7, 8, 9], [ 0, 1, 2, 3, 4]]) 1x[::-1,::-1] array([[14, 13, 12, 11, 10], [ 9, 8, 7, 6, 5], [ 4, 3, 2, 1, 0]]) 1subx = x[0:2,0:2] #取子矩阵，注意是引用的形式！如果更改subx中的元素，x相应元素也会被修改 1subx array([[0, 1], [5, 6]]) 12subx[0,0] = 100subx array([[100, 1], [ 5, 6]]) 1x #此时，x的对应元素也被修改啦 array([[100, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [ 10, 11, 12, 13, 14]]) .copy1subx = x[0:2,0:3].copy() #使用copy方法 不是引用的方式，此时更改subx, x的元素不会改变 12subx[0,0]=999subx array([[999, 1, 2], [ 5, 6, 7]]) 1x #此时，x对应元素并没有被修改 array([[100, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [ 10, 11, 12, 13, 14]]) reshape1x.reshape(5,-1) #等价于x.reshape(5,3)，第二个维度写-1会让计算机自行进行计算，如果计算的结果不是整数就会报错 array([[100, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [ 12, 13, 14]])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两道笔试题分享]]></title>
    <url>%2F2018%2F09%2F09%2F%E4%B8%A4%E9%81%93%E7%AC%94%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[最近在忙着秋招笔试,几乎每天都有笔试，心累。虽然我的各种数据结构与算法知识是一个月前刚刚学习的，但是也投了很多算法岗，去凑个热闹。下面分享两道我能够做出来的习题(虽然大家觉得很简单，但对我这种菜鸟才说，第一次AC还是蛮激动的)。 科大的一道笔试题今年科大的笔试题听他们说特别简单，十分钟双AC下面是其中一道： 下面是我的代码(Python3)：12345678910111213141516171819202122group = int(input())res = []for num in range(group): temp = input().split() people,score = int(temp[0]),int(temp[1]) product = people * score tmp = input().split() score_list = list(map(int,tmp)) if sum(score_list) &gt;= product: res.append(0) else: score_list.sort() for i in range(len(score_list)): score_list[i] = 100 if sum(score_list) &gt;= product: res.append(i+1) breakfor j in res: print(j) 网易的一道笔试题我内推的时候投了网易的数据分析岗，结果笔试没过，不知道哪里来的勇气，秋招投了有道事业部的推荐算法岗，考试题型分为三个部分，包括20道选择题，3道编程题，2道问答题。选择题比较综合，考了数据结构、Linux&amp;Shell、Java、C++、Python、机器学习的常用算法（SVM、决策树、随机森林）。问答题有两道，第一道是让我构建一个用户品牌偏好模型，我就随便了两句，比如协同推荐、品牌用户聚类什么的。第二道是问我对LTR模型的看法，我连LTR是啥都不知道，后来查了一下，LTR全称是Learning to rank，是一种重要性排序的算法。以下是一道笔试题：我当时实在是不知道怎么去做，后来昨晚睡觉的时候一直在想思路（我为啥没想另外两道呢？因为那两道我连题都没读懂）。后来终于想通了，结果失眠了…思路：找出被翻转次数为奇数的小方格，也就是中心区域的那些。下面是我的代码(Python3)：12345678910111213group = int(input())for i in range(group): n,m = map(int,input().split()) if n == 1: if m == 1: print(1) else: print(m-2) else: if m ==1: print(0) else: print((n-2)*(m-2)) 下面分享一个我在论坛上看到一个大神的思路(Python2)：12345678#作者：bisect#链接：https://www.nowcoder.com/discuss/105595#来源：牛客网t = input()for _ in xrange(t): n,m = map(int,raw_input().split()) print [n-2,1][n==1] * [m-2,1][m==1] 看完我都震惊了，太秀了，果然人与人的差距不是一点半点。]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手写PCA]]></title>
    <url>%2F2018%2F09%2F03%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99PCA%2F</url>
    <content type="text"><![CDATA[PCA的简单介绍：PCA,全称为Principal Component Analysis，中文翻译叫做“主成分分析”，是一种常用的降维方法，可以将n维数据降到1-n维。 PCA的数学原理：待写… 使用Python自己写一个PCA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import numpy as npclass PCA: def __init__(self, n_components): """初始化PCA""" assert n_components &gt;= 1, "n_components must be valid" self.n_components = n_components self.components_ = None def fit(self, X, eta=0.01, n_iters=1e4): """获得数据集X的前n个主成分""" assert self.n_components &lt;= X.shape[1], \ "n_components must not be greater than the feature number of X" def demean(X): """将每个特征都平移“均值”个单位""" return X - np.mean(X, axis=0) def f(w, X): """定义目标函数，求解主元的过程也就是使该函数取得最大值""" return np.sum((X.dot(w) ** 2)) / len(X) def df(w, X): """求解目标函数的梯度""" return X.T.dot(X.dot(w)) * 2. / len(X) def direction(w): """将主元进行单位化""" return w / np.linalg.norm(w) def first_component(X, initial_w, eta=0.01, n_iters=1e4, epsilon=1e-8): """使用梯度上升的方法求解主元""" w = direction(initial_w) cur_iter = 0 while cur_iter &lt; n_iters: gradient = df(w, X) last_w = w w = w + eta * gradient w = direction(w) if (abs(f(w, X) - f(last_w, X)) &lt; epsilon): break cur_iter += 1 return w X_pca = demean(X) self.components_ = np.empty(shape=(self.n_components, X.shape[1])) for i in range(self.n_components): """循环n次，求解前n个主元""" initial_w = np.random.random(X_pca.shape[1]) w = first_component(X_pca, initial_w, eta, n_iters) self.components_[i,:] = w //将求出的第i个主元存储在components的第i行上 X_pca = X_pca - X_pca.dot(w).reshape(-1, 1) * w #求出第i个主元后，将样本集减掉这一主元 return self def transform(self, X): """将给定的X，映射到各个主成分分量中""" assert X.shape[1] == self.components_.shape[1] return X.dot(self.components_.T) def inverse_transform(self, X): """将给定的X，反向映射回原来的特征空间""" assert X.shape[1] == self.components_.shape[0] return X.dot(self.components_) def __repr__(self): return "PCA(n_components=%d)" % self.n_components 如何使用这个类：12345678910111213import numpy as npimport matplotlib.pyplot as pltX = np.empty((100, 2)) #生成100个二维样本X[:,0] = np.random.uniform(0., 100., size=100)X[:,1] = 0.75 * X[:,0] + 3. + np.random.normal(0, 10., size=100)import PCA #自己封装的PCA函数pca = PCA(n_components=1) #实例化，设定主元个数为2pca.fit(X) #求解两个主元,可以使用pca.components_打印一下求解的这两个主元X_reduction = pca.transform(X) #将X变成一维的样本X_restore = pca.inverse_transform(X_reduction) #将X再转换成二维的，此时已经损失了很多的信息量plt.scatter(X[:,0], X[:,1], color='b', alpha=0.5)plt.scatter(X_restore[:,0], X_restore[:,1], color='r', alpha=0.5)plt.show() #蓝色表示原来的样本，红色表示降维后又重新转换成二维样本的结果，可以看出已经损失了信息量 如图所示： 使用scikit-learn如何调用PCA注意:sklearn中求主元 用的并不是梯度上升的方法123456789from sklearn.decomposition import PCApca = PCA(n_components=1) #实例化，主元个数设定为1pca.fit(X) #求解主元pca.components_ #打印主元X_reduction = pca.transform(X) #对样本进行降维X_restore = pca.inverse_transform(X_reduction) #将样本重新进行升维plt.scatter(X[:,0], X[:,1], color='b', alpha=0.5)plt.scatter(X_restore[:,0], X_restore[:,1], color='r', alpha=0.5)plt.show() 如图所示： From :刘宇波 python3入门机器学习]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>特征工程</tag>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda的常用指令]]></title>
    <url>%2F2018%2F09%2F03%2FAnaconda%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Anaconda的常用指令Anaconda 是最流行的数据科学平台，它附带了conda、python和150多个科学包及其依赖项，conda是一种python环境管理程序。下面来介绍一下 Anaconda 的环境搭建以及常用命令：Anaconda配置完成后，可以看到有 Anaconda prompt，叫做终端，以下指令在终端上运行： 1、查看Ananconda版本1conda --version 2、升级当前版本的conda，安装完了以后最好都要执行一下这个命令：1conda updata conda 3、conda添加清华的镜像123conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channels_urls yes #设置在是否安装的时候显示该链接 移除镜像1conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free 4、创建环境：创建一个命名为bash_env的python3.5的环境，此时anaconda/envs文件下就会多一个bash_env的文件夹，存放这个环境1conda creat -n bash_env python=3.5 查看帮助文件：1conda creat --help 或者1conda creat -h 5、激活切换到这个环境中来1activate bash_env #如果是linux或者mac系统前面加source 6、检查该环境下的python版本1python --version 7、在当前环境下安装各种包12345conda install numpyconda install opencv-pythonconda install matplotlibconda install scipyconda install pandas 或者简写成1conda install numpy opencv-python matplotlib scipy pandas 声明这个包要安装到那个环境中去，否则安装到当前环境中1conda install --name py35 pandas 8、更新当前环境中所有的包1conda updata -all 9、查找包：比如查找beautifulsoup4的包1conda search beautifulsoup4 10、移除包：1conda remove -n env_name package_name 11、查看这个环境下的包列表1conda list 12、克隆环境创建一个名为pytorch_env的环境，克隆base_env的配置，并且安装pytorch12conda creat -n pytorch_env --clone base_envactivate pytorch_env #linux系统加source 安装pytorch的指令参考这个网站:https://pytorch.org/12conda install pytorch-cpu -c pytorchpip install torchvision 13、创建环境，同时安装包创建名为bunnies的python3环境，同时安装Astroid和Babel1conda creat -n business python=3 Astroid Babel 14、列出当前所有的环境1conda env list #列出所有环境名称，带*表示目前在哪个环境下 15、列出目前所有环境的python版本1conda info -e 16、注销并退出环境从当前工作环境的路径切换到系统根目录1deactivate #Linux和mac使用source deactivate 17、导出环境配置1conda env export &gt; envir_name.ymal 18、导入配置且安装环境导入ymal文件所配置的环境1conda env creat -f /path/envir_name.ymal 19、移除环境比如移除名为base_env的环境：1conda remove -n base_env --all 查看完整的帮助文件1conda remove -h 20、本地安装第三方包1conda install --offline xx/xx/xx/tar.bz2 #第三方包离线地址 21、从Anaconda.org安装一个包当一个包不能使用conda指令安装的时候，可以从这个网站去查找1conda install -c intel scipy conda指令安装不了的包也可以使用pip来安装，pip是一个包管理器，也被集成在Anaconda中 22、pycharm选择Anaconda配置好的环境file → Setting → project → project interpreter23、添加中科大镜像并切换到这个镜像12conda config -add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/conda config -set show_channels_urls yes 另外：如果不喜欢使用命令行，可以可以图形界面：Anaconda-navigator，强烈推荐新手使用！ 有关Anaconda的更多介绍可以参考官方文档：https://docs.anaconda.com/anaconda/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github和hexo搭建个人网站]]></title>
    <url>%2F2018%2F08%2F19%2F%E4%BD%BF%E7%94%A8Github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[这几天学习了一下Hexo搭建个人网站的基本操作： 使用Hexo 和Github 搭建个人网站 个人网站的配置与主题更换 开始写文章 第一步、使用Hexo和GIthub搭建个人网站1、准备工作:下载并安装Git、注册Github账号、下载并安装node.js、 使用ssh密匙将本地仓库与Github进行关联2、安装Hexo在我的电脑的D盘新建一个文件夹”bolg”,右键命令行，输入如图： $ npm install hexo-cli -g (来自Hexo 中文网站 https://hexo.io/zh-cn) (npm是随node.js附带安装的包管理工具） (Hexo是一个搭建个人网站的框架)3、使用如下命令在该路径下初始化自己的博客 $ hexo init XLJ_Blog 如图： 4、进入博客目录，npm的本地安装： $ cd XLJ_Blog $ npm install 如图： 5、本地测试运行 选择5555端口 $ hexo s -p 5555 如图： 进入浏览器，输入localhost:5555,即可进入6、安装sublime（一个推荐使用的编辑工具) 将自己的博客文件夹 XLJ_Blog 拖进去即可编辑修改7、将自己的博客绑定至Github,然后安装 hexo-deployer-git $ npm install hexo-deployer-git --save 打开 _config.yml 修改最后一行的type，如图所示: (红黄之间一定要有空格！！！) 修改url，上面的title,subtitle,author，description等选项也都可以填上，可以在你的首页显示,如图： 8、生成网页并部署 $ hexo g 生成 $ hexo d 部署 部署之前可以 使用 $ hexo s -p 5555 在本地预览一下 这时候会把文件上传到你的Github的个人博客库中去，之前库中的文件会全部删掉，此时从浏览器进入：http://用户名.github.io ,就可以看到你的个人网站已经搭建好啦 第二步、个人网站的配置与主题更换搭建好了网站以后，就可以随心所欲的配置你的个人网站啦可以选择几个比较好看的主题：进入 http://hexo.io/themes/ ,选择一个喜欢的模板，几个简约的主题：比如JSimple、AirCloud、 Anatole 然后找到主题对应的Github库，复制地址，在桌面右键进入Git bash 命令行，对主题进行下载，指令如下：git clone https://github.com/aircloud/hexo-theme-aircloud.gitcd hexo-theme-aircloudnpm install然后将这个文件夹放入到个人博客文件夹中的themes文件夹中，打开个人博客文件夹中的个人网站配置文件__config.yml 找到 themes ，由 landscape修改成刚才放到themes中的那个文件夹的名字。然后重新生成网页并部署，指令如下:生成文件 ：$ hexo g本地测试 $ hexo s -p 5555浏览器输入 localhost:5555 进行预览预览没有问题的话 使用 Ctrl+C 关掉进行部署 $ hexo d 我个人推荐使用Next主题，这个主题比较成熟，配置起来的比较容易，因为网上有很多教程，比较适合我这样的小白 （http://theme-next.iissnan.com/getting-started.html next主题使用文档）首先进行下载,去官网找到最新版，选择zip压缩包下载；然后解压缩，还是放到刚才提到的 themes这个文件夹中去，为了后续配置方便，把这个主题文件改个名字，就叫next，去掉后面的版本号。然后在网站配置文件__config.yml 找到 themes，改成 next.然后重新生成并在本地预览一下，还是上面的指令:$ hexo g$ hexo s -p 5555关于Next的主题配置可以参考官方文档（http://theme-next.iissnan.com/） 和这个非常详细的教程（https://www.jianshu.com/p/1f8107a8778c）每次配置后 ，要进行的操作 (四步走)首先进行清理： $ hexo clean生成： $ hexo g本地预览测试(可省略)： $ hexo s -p 5555部署： $ hexo d 第三步、开始写文章1、创建文章在站点文件夹中打开git bash，输入如下命令创建文章，其中title为文章的标题$ hexo new &quot;title&quot;此时就会在source/_post文件夹中创建了一个文件，命名为：title.md，而这个文件就是将要发布到网站上的原始文件，记录文章内容2、编写文章 (基于markdown语法)3、部署发布 (还是参考上面的四步走操作)]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的常用指令]]></title>
    <url>%2F2018%2F08%2F18%2Fgit%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[以下是Git的常用指令 12345678910111213141516171819202122232425262728mkdir： XX #(创建一个空目录 XX 指目录名)pwd #显示当前目录的路径。git init #把当前的目录变成可以管理的 git仓库，生成隐藏.git 文件。git add XX #把 xx 文件添加到暂存区去。git commit –m “XX” 提交文件 #–m 后面的是注释。git status #查看仓库状态git diff XX #查看 XX 文件修改了那些内容git log #查看历史记录git reset –hard HEAD^ #或者 git reset –hard HEAD~ 回退到上一个版本(如果想回退到 100个版本，使用 git reset –hard HEAD~100 )cat XX #查看 XX 文件内容git reflog #查看历史记录的版本号 idgit checkout — XX #把 XX 文件在工作区的修改全部撤销git rm XX #删除 XX 文件git remote add origin https://github.com/github_account/repository.git #关联一个远程库git clone https://github.com/github_account/reporistory.git #从远程库中克隆git checkout –b dev #创建 dev 分支 并切换到 dev 分支上git branch #查看当前所有的分支git checkout master #切换回 master 分支git merge dev #在当前的分支上合并 dev 分支git branch –d dev #删除 dev 分支git branch name #创建分支git stash #把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list #查看所有被隐藏的文件列表git stash apply #恢复被隐藏的文件，但是内容不删除git stash drop #删除文件git stash pop #恢复文件的同时 也删除文件git remote #查看远程库的信息git remote –v #查看远程库的详细信息]]></content>
      <categories>
        <category>Git和Github</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎访问，这是徐珑嘉的个人博客一、个人博客介绍这个博客是使用hexo框架搭建的，主题是 next 二、如何写文章？hexo支持makedown语法，具体见：https://segmentfault.com/markdown (markdown 基本语法) 1、html字体设置如下： 设置颜色 设置大小 设置颜色和大小 这一行需要居中 2、Markdown字体设置：加粗斜体斜体加粗删除线 3、代码块：这个是Python的代码块123456789#!/usr/bin/python# -*- coding: UTF-8 -*- l = []for i in range(3): x = int(raw_input('integer:\n')) l.append(x)l.sort()print l 这个是java的代码块12345public class HelloWorld &#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; 这个是R的代码块1234567setwd("D:\\R_edu\\data")rm(list=ls())accepts&lt;-read.csv("accepts.csv")str(accepts)accepts$bad_ind&lt;-as.factor(accepts$bad_ind)names(accepts)accepts=accepts[,c(3,7:24)] 这个是bash的代码块12345678910pwdcd D:dirmkdir test_dicttouch hello.pygit add .git statusgit commit -m "a description"git pushhexo g 只有一行的代码这样写：prinf(&quot;hello world&quot;) 4、插入图片：插入网络图片：插入本地图片： 5、引用： hexo cleanhexo g #生成网页hexo s -p 5555 #本地预览hexo d #部署]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
